# EEI Power Supply UNIMAG Interface
# Provides simplified current control with automatic polarity and sequencing
# Requires eei_ps.template to be loaded
# Logic implemented in unimagControl.st (SNL state program)

# ################### UNIMAG State Machine Status ####################
# State machine internal state (matches OCEM UNIMAG implementation)
record(longin, "$(P):SM_STATE_RB")
{
    field(DESC, "State Machine State")
    field(EGU,  "")
}

# State machine busy flag
record(bo, "$(P):SM_BUSY_RB") 
{
    field(DESC, "State Machine Busy")
    field(ZNAM, "READY")
    field(ONAM, "BUSY")
}

# State machine status message
record(stringin, "$(P):SM_STATUS_MSG")
{
    field(DESC, "State Machine Status")
    field(VAL,  "Initializing")
}

# Debug level control
record(longout, "$(P):DEBUG_LEVEL")
{
    field(DESC, "Debug Logging Level")
    field(EGU,  "")
    field(DRVH, "3")
    field(DRVL, "0")
    field(VAL,  "1")
    field(PINI, "YES")
}

# ################### UNIMAG Current Setpoint ####################
# User sets current in A (positive or negative) 
# PV format: $(P):CURRENT_SP
# Monitored by SNL program for automatic sequencing
record(ao, "$(P):CURRENT_SP")
{
    field(DESC, "Current Setpoint (signed)")
    field(EGU,  "A")
    field(PREC, "3")
    field(DRVH, "$(MAX_CURR=330)")
    field(DRVL, "$(MIN_CURR=-330)")
    field(HOPR, "$(MAX_CURR=330)")
    field(LOPR, "$(MIN_CURR=-330)")
    field(FLNK, "$(P):CURRENT_RB")
}

# ################### Status Readback ####################
# Signed current readback (applies polarity sign to raw current)
# PV format: $(P):CURRENT_SIGNED_RB
# Note: $(P):CURRENT_RB exists in eei_ps.template as raw Modbus readback
record(calcout, "$(P):CURRENT_SIGNED_RB")
{
    field(DESC, "Current Readback (signed)")
    field(INPA, "$(P):CURR_RB CP")
    field(INPB, "$(P):STAT_POLARITY_POS CP")
    field(INPC, "$(P):STAT_POLARITY_NEG CP")
    field(CALC, "B?A:(C?-A:A)")
    field(EGU,  "A")
    field(PREC, "3")
}

# Overall status readback - comprehensive state decode matching OCEM format
# PV format: $(P):STATUS_RB  
# Enhanced with 8-state enumeration matching OCEM E642 implementation
# States: 0=OFF, 1=STANDBY, 2=ON, 3=NOT_REACHED, 4=RAMPING, 5=STBY_TIMEOUT, 6=SET_TIMEOUT, 7=FAULT
record(calcout, "$(P):STATUS_DECODE")
{
    field(DESC, "Comprehensive PS State Decode")
    field(INPA, "$(P):STAT_STANDBY CP")        # A: Standby status
    field(INPB, "$(P):STAT_POWER_ON CP")       # B: Power on status  
    field(INPC, "$(P):STAT_FAULTY CP")         # C: Fault status
    field(INPD, "$(P):STAT_RAMPING CP")        # D: Ramping status (from Modbus if available)
    field(INPE, "$(P):SM_BUSY_RB CP")          # E: State machine busy
    field(INPF, "$(P):SM_STATE_RB CP")         # F: State machine state  
    field(INPG, "$(P):CURR_RB CP")             # G: Current readback
    field(INPH, "$(P):CURRENT_SP CP")          # H: Current setpoint
    # Comprehensive state logic:
    # Priority: FAULT > RAMPING > state machine states > power states
    field(CALC, "C?7:(D||E?4:(F==3||F==4||F==5?3:(F==6?4:(A?1:(B?2:0)))))")
    field(OUT,  "$(P):STATUS_RB PP")
}

record(mbbi, "$(P):STATUS_RB")
{
    field(DESC, "Power Supply Status")
    field(INP,  "$(P):STATUS_DECODE NPP MS")
    field(ZRST, "OFF")
    field(ONST, "STANDBY")
    field(TWST, "ON")
    field(THST, "NOT_REACHED")
    field(FRST, "RAMPING")
    field(FVST, "STBY_TIMEOUT")
    field(SXST, "SET_TIMEOUT")
    field(SVST, "FAULT")
    field(ZRVL, "0")
    field(ONVL, "1")
    field(TWVL, "2")
    field(THVL, "3")
    field(FRVL, "4")
    field(FVVL, "5")
    field(SXVL, "6")
    field(SVVL, "7")
    field(ZRSV, "NO_ALARM")
    field(ONSV, "NO_ALARM")
    field(TWSV, "NO_ALARM")
    field(THSV, "MINOR")
    field(FRSV, "MINOR")
    field(FVSV, "MAJOR")
    field(SXSV, "MAJOR")
    field(SVSV, "MAJOR")
}

# Legacy STATE_RB for backward compatibility
record(calcout, "$(P):STATE_DECODE")
{
    field(DESC, "Legacy State Decode")
    field(INPA, "$(P):STATUS_RB CP")
    field(CALC, "(A==7)?3:((A>=1&&A<=2)?A:((A>=3&&A<=4)?1:1))")
    field(OUT,  "$(P):STATE_RB PP")
}

record(mbbi, "$(P):STATE_RB")
{
    field(DESC, "Legacy Power Supply State")
    field(INP,  "$(P):STATE_DECODE NPP MS")
    field(ONST, "ON") 
    field(TWST, "STANDBY")
    field(THST, "FAULT")
    field(ONVL, "1")
    field(TWVL, "2")
    field(THVL, "3")
    field(ONSV, "NO_ALARM")
    field(TWSV, "NO_ALARM")
    field(THSV, "MAJOR")
}

# State control setpoint
# PV format: $(P):STATE_SP
# Allows user to command state changes: STANDBY, ON, RESET, OFF
record(mbbo, "$(P):STATE_SP")
{
    field(DESC, "Set Power Supply State")
    field(ZRST, "OFF")
    field(ONST, "ON")
    field(TWST, "STANDBY")
    field(THST, "RESET")
    field(ZRVL, "0")
    field(ONVL, "1")
    field(TWVL, "2")
    field(THVL, "3")
    field(FLNK, "$(P):STATE_PROCESS")
}

# Process state change requests
record(seq, "$(P):STATE_PROCESS")
{
    field(DESC, "Process State Command")
    field(SELM, "Specified")
    field(SELL, "$(P):STATE_SP NPP MS")
    # Link 0: OFF command â†’ go to STANDBY
    field(DOL0, "1")
    field(LNK0, "$(P):CMD_STANDBY PP")
    # Link 1: ON command
    field(DOL1, "1")
    field(LNK1, "$(P):CMD_POWER_ON PP")

    # Link 2: STANDBY command
    field(DOL2, "1")
    field(LNK2, "$(P):CMD_STANDBY PP")

    # Link 3: RESET command
    field(DOL3, "1")
    field(LNK3, "$(P):CMD_RESET PP")
}

# Interlock status
record(calc, "$(P):INTERLOCKED")
{
    field(DESC, "Interlock Active")
    field(INPA, "$(P):STAT_FAULTY CP")
    field(CALC, "A")
}
